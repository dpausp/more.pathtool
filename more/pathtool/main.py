from __future__ import print_function

import argparse
import inspect
from dectate import Query
from dectate.tool import parse_app_class  # XXX implementation detail
from morepath.directive import ViewAction, PathAction, MountAction


def path_tool(app_class):
    """Command-line query tool for Morepath path information.

    Displays information about all paths generated by a Morepath
    app, including points of definition.

    usage: morepath_paths [-h] [--app APP]

    param app_class: the root :class:`App` subclass to query by default.
    """
    parser = argparse.ArgumentParser(description="Query Morepath paths")
    parser.add_argument('--app', help="Dotted name for App subclass.",
                        type=parse_app_class)
    args, filters = parser.parse_known_args()

    if args.app:
        app_class = args.app

    for line in path_tool_output(app_class):
        print(line)


def max_length(infos, name):
    return max([len(d[name]) for d in infos])


def path_tool_output(app_class):
    infos = get_path_and_view_info(app_class)
    for info in infos:
        if 'predicates' not in info:
            predicates_s = ''
        else:
            predicates_s = ','.join(
                ['%s=%s' % (name, value)
                 for name, value in sorted(info['predicates'].items())])
        info['predicates_s'] = predicates_s

    max_path_length = max_length(infos, 'path')
    max_predicates_s_length = max_length(infos, 'predicates_s')
    max_directive_length = max_length(infos, 'directive')

    max_path_length = max([max_path_length, max_predicates_s_length])

    t_path = ("{path:<{max_path_length}} "
              "{directive:<{max_directive_length}} "
              "{filelineno}")
    t_view = ("{predicates:<{max_path_length}} "
              "{directive:<{max_directive_length}} "
              "{filelineno}")
    for info in infos:
        if 'predicates' in info:
            info['predicates'] = ','.join(
                ['%s=%s' % (name, value)
                 for name, value in sorted(info['predicates'].items())])
            yield t_view.format(
                max_path_length=max_path_length,
                max_directive_length=max_directive_length,
                **info)
        else:
            yield t_path.format(
                max_path_length=max_path_length,
                max_directive_length=max_directive_length,
                **info)


def get_path_and_view_info(app_class):
    result = []
    for action, path in get_path_and_view_actions(app_class):
        directive = action.directive
        # XXX in next release of dectate can use directive.directive_name again
        directive_name = directive.configurable._action_classes[
            directive.action_factory]
        d = {'directive': directive_name,
             'filelineno': directive.code_info.filelineno(),
             'path': path}
        if isinstance(action, ViewAction):
            d['predicates'] = action.predicates
        result.append(d)
    result.sort(key=lambda d: (
        d['path'], d['directive'] not in ['path', 'mount']))
    return result


def get_path_and_view_actions(app_class, base_path=''):
    model_to_view = {}
    q = Query(ViewAction)
    for action, f in q(app_class):
        model_to_view.setdefault(action.model, []).append(action)

    for action, path in get_path_actions(app_class, base_path):
        yield action, path
        if isinstance(action, MountAction):
            for sub_action, sub_path in get_path_and_view_actions(
                    action.app, path):
                yield sub_action, sub_path
            continue
        for view_action, view_path in get_view_actions(app_class, path,
                                                       model_to_view,
                                                       action.model):
            yield view_action, view_path


def get_path_actions(app_class, base_path):
    q = Query(PathAction)
    for action, f in q(app_class):
        path = '/'.join([base_path, normalize_path(action.path)])
        yield action, path


def get_view_actions(app_class, base_path, model_to_view, model):
    view_actions = []
    for class_ in inspect.getmro(model):
        view_actions.extend(model_to_view.get(class_, []))
    for view_action in view_actions:
        name = view_action.predicates.get('name', '')
        path = base_path
        if name:
            path = path + '/+' + name
        yield view_action, path


def normalize_path(path):
    if path.startswith('/'):
        path = path[1:]
    if path.endswith('/'):
        path = path[:-1]
    return path
